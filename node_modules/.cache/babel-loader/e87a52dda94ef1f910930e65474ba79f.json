{"ast":null,"code":"import { addDays, differenceInDays, formatISO, parseISO, startOfDay } from 'date-fns';\nimport { default as GraphemeSplitter } from 'grapheme-splitter';\nimport queryString from 'query-string';\nimport { ENABLE_ARCHIVED_GAMES } from '../constants/settings';\nimport { NOT_CONTAINED_MESSAGE, WRONG_SPOT_MESSAGE } from '../constants/strings';\nimport { VALID_GUESSES } from '../constants/validGuesses';\nimport { WORDS } from '../constants/wordlist';\nimport { getToday } from './dateutils';\nimport { getGuessStatuses } from './statuses'; // 1 January 2022 Game Epoch\n\nexport const firstGameDate = new Date(2022, 0);\nexport const periodInDays = 1;\nexport const isWordInWordList = word => {\n  return WORDS.includes(localeAwareLowerCase(word)) || VALID_GUESSES.includes(localeAwareLowerCase(word));\n};\nexport const isWinningWord = word => {\n  return solution === word;\n};\nexport const getValidGuesses = () => {\n  return;\n}; // build a set of previously revealed letters - present and correct\n// guess must use correct letters in that space and any other revealed letters\n// also check if all revealed instances of a letter are used (i.e. two C's)\n\nexport const findFirstUnusedReveal = (word, guesses) => {\n  if (guesses.length === 0) {\n    return false;\n  }\n\n  const lettersLeftArray = new Array();\n  const guess = guesses[guesses.length - 1];\n  const statuses = getGuessStatuses(solution, guess);\n  const splitWord = unicodeSplit(word);\n  const splitGuess = unicodeSplit(guess);\n\n  for (let i = 0; i < splitGuess.length; i++) {\n    if (statuses[i] === 'correct' || statuses[i] === 'present') {\n      lettersLeftArray.push(splitGuess[i]);\n    }\n\n    if (statuses[i] === 'correct' && splitWord[i] !== splitGuess[i]) {\n      return WRONG_SPOT_MESSAGE(splitGuess[i], i + 1);\n    }\n  } // check for the first unused letter, taking duplicate letters\n  // into account - see issue #198\n\n\n  let n;\n\n  for (const letter of splitWord) {\n    n = lettersLeftArray.indexOf(letter);\n\n    if (n !== -1) {\n      lettersLeftArray.splice(n, 1);\n    }\n  }\n\n  if (lettersLeftArray.length > 0) {\n    return NOT_CONTAINED_MESSAGE(lettersLeftArray[0]);\n  }\n\n  return false;\n};\nexport const unicodeSplit = word => {\n  return new GraphemeSplitter().splitGraphemes(word);\n};\nexport const unicodeLength = word => {\n  return unicodeSplit(word).length;\n};\nexport const localeAwareLowerCase = text => {\n  return process.env.REACT_APP_LOCALE_STRING ? text.toLocaleLowerCase(process.env.REACT_APP_LOCALE_STRING) : text.toLowerCase();\n};\nexport const localeAwareUpperCase = text => {\n  return process.env.REACT_APP_LOCALE_STRING ? text.toLocaleUpperCase(process.env.REACT_APP_LOCALE_STRING) : text.toUpperCase();\n};\nexport const getLastGameDate = today => {\n  const t = startOfDay(today);\n  let daysSinceLastGame = differenceInDays(firstGameDate, t) % periodInDays;\n  return addDays(t, -daysSinceLastGame);\n};\nexport const getNextGameDate = today => {\n  return addDays(getLastGameDate(today), periodInDays);\n};\nexport const isValidGameDate = date => {\n  if (date < firstGameDate || date > getToday()) {\n    return false;\n  }\n\n  return differenceInDays(firstGameDate, date) % periodInDays === 0;\n};\nexport const getIndex = gameDate => {\n  let start = firstGameDate;\n  let index = -1;\n\n  do {\n    index++;\n    start = addDays(start, periodInDays);\n  } while (start <= gameDate);\n\n  return index;\n};\nexport const getWordOfDay = index => {\n  if (index < 0) {\n    throw new Error('Invalid index');\n  }\n\n  return localeAwareUpperCase(WORDS[index % WORDS.length]);\n};\nexport const getSolution = gameDate => {\n  const nextGameDate = getNextGameDate(gameDate);\n  const index = getIndex(gameDate);\n  const wordOfTheDay = getWordOfDay(index);\n  return {\n    solution: wordOfTheDay,\n    solutionGameDate: gameDate,\n    solutionIndex: index,\n    tomorrow: nextGameDate.valueOf()\n  };\n};\nexport const getGameDate = () => {\n  if (getIsLatestGame()) {\n    return getToday();\n  }\n\n  const parsed = queryString.parse(window.location.search);\n\n  try {\n    const d = startOfDay(parseISO(parsed.d.toString()));\n\n    if (d >= getToday() || d < firstGameDate) {\n      setGameDate(getToday());\n    }\n\n    return d;\n  } catch (e) {\n    console.log(e);\n    return getToday();\n  }\n};\nexport const setGameDate = d => {\n  try {\n    if (d < getToday()) {\n      window.location.href = '/?d=' + formatISO(d, {\n        representation: 'date'\n      });\n      return;\n    }\n  } catch (e) {\n    console.log(e);\n  }\n\n  window.location.href = '/';\n};\nexport const getIsLatestGame = () => {\n  if (!ENABLE_ARCHIVED_GAMES) {\n    return true;\n  }\n\n  const parsed = queryString.parse(window.location.search);\n  return parsed === null || !('d' in parsed);\n};\nexport const {\n  solution,\n  solutionGameDate,\n  solutionIndex,\n  tomorrow\n} = getSolution(getGameDate());","map":{"version":3,"sources":["/Users/Jonny/Desktop/wordle-solver/src/lib/words.ts"],"names":["addDays","differenceInDays","formatISO","parseISO","startOfDay","default","GraphemeSplitter","queryString","ENABLE_ARCHIVED_GAMES","NOT_CONTAINED_MESSAGE","WRONG_SPOT_MESSAGE","VALID_GUESSES","WORDS","getToday","getGuessStatuses","firstGameDate","Date","periodInDays","isWordInWordList","word","includes","localeAwareLowerCase","isWinningWord","solution","getValidGuesses","findFirstUnusedReveal","guesses","length","lettersLeftArray","Array","guess","statuses","splitWord","unicodeSplit","splitGuess","i","push","n","letter","indexOf","splice","splitGraphemes","unicodeLength","text","process","env","REACT_APP_LOCALE_STRING","toLocaleLowerCase","toLowerCase","localeAwareUpperCase","toLocaleUpperCase","toUpperCase","getLastGameDate","today","t","daysSinceLastGame","getNextGameDate","isValidGameDate","date","getIndex","gameDate","start","index","getWordOfDay","Error","getSolution","nextGameDate","wordOfTheDay","solutionGameDate","solutionIndex","tomorrow","valueOf","getGameDate","getIsLatestGame","parsed","parse","window","location","search","d","toString","setGameDate","e","console","log","href","representation"],"mappings":"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","sourcesContent":["import {\n  addDays,\n  differenceInDays,\n  formatISO,\n  parseISO,\n  startOfDay,\n} from 'date-fns'\nimport { default as GraphemeSplitter } from 'grapheme-splitter'\nimport queryString from 'query-string'\n\nimport { ENABLE_ARCHIVED_GAMES } from '../constants/settings'\nimport { NOT_CONTAINED_MESSAGE, WRONG_SPOT_MESSAGE } from '../constants/strings'\nimport { VALID_GUESSES } from '../constants/validGuesses'\nimport { WORDS } from '../constants/wordlist'\nimport { getToday } from './dateutils'\nimport { getGuessStatuses } from './statuses'\n\n// 1 January 2022 Game Epoch\nexport const firstGameDate = new Date(2022, 0)\nexport const periodInDays = 1\n\nexport const isWordInWordList = (word: string) => {\n  return (\n    WORDS.includes(localeAwareLowerCase(word)) ||\n    VALID_GUESSES.includes(localeAwareLowerCase(word))\n  )\n}\n\nexport const isWinningWord = (word: string) => {\n  return solution === word\n}\n\nexport const getValidGuesses = () => {\n  return\n}\n\n// build a set of previously revealed letters - present and correct\n// guess must use correct letters in that space and any other revealed letters\n// also check if all revealed instances of a letter are used (i.e. two C's)\nexport const findFirstUnusedReveal = (word: string, guesses: string[]) => {\n  if (guesses.length === 0) {\n    return false\n  }\n\n  const lettersLeftArray = new Array<string>()\n  const guess = guesses[guesses.length - 1]\n  const statuses = getGuessStatuses(solution, guess)\n  const splitWord = unicodeSplit(word)\n  const splitGuess = unicodeSplit(guess)\n\n  for (let i = 0; i < splitGuess.length; i++) {\n    if (statuses[i] === 'correct' || statuses[i] === 'present') {\n      lettersLeftArray.push(splitGuess[i])\n    }\n    if (statuses[i] === 'correct' && splitWord[i] !== splitGuess[i]) {\n      return WRONG_SPOT_MESSAGE(splitGuess[i], i + 1)\n    }\n  }\n\n  // check for the first unused letter, taking duplicate letters\n  // into account - see issue #198\n  let n\n  for (const letter of splitWord) {\n    n = lettersLeftArray.indexOf(letter)\n    if (n !== -1) {\n      lettersLeftArray.splice(n, 1)\n    }\n  }\n\n  if (lettersLeftArray.length > 0) {\n    return NOT_CONTAINED_MESSAGE(lettersLeftArray[0])\n  }\n  return false\n}\n\nexport const unicodeSplit = (word: string) => {\n  return new GraphemeSplitter().splitGraphemes(word)\n}\n\nexport const unicodeLength = (word: string) => {\n  return unicodeSplit(word).length\n}\n\nexport const localeAwareLowerCase = (text: string) => {\n  return process.env.REACT_APP_LOCALE_STRING\n    ? text.toLocaleLowerCase(process.env.REACT_APP_LOCALE_STRING)\n    : text.toLowerCase()\n}\n\nexport const localeAwareUpperCase = (text: string) => {\n  return process.env.REACT_APP_LOCALE_STRING\n    ? text.toLocaleUpperCase(process.env.REACT_APP_LOCALE_STRING)\n    : text.toUpperCase()\n}\n\nexport const getLastGameDate = (today: Date) => {\n  const t = startOfDay(today)\n  let daysSinceLastGame = differenceInDays(firstGameDate, t) % periodInDays\n  return addDays(t, -daysSinceLastGame)\n}\n\nexport const getNextGameDate = (today: Date) => {\n  return addDays(getLastGameDate(today), periodInDays)\n}\n\nexport const isValidGameDate = (date: Date) => {\n  if (date < firstGameDate || date > getToday()) {\n    return false\n  }\n\n  return differenceInDays(firstGameDate, date) % periodInDays === 0\n}\n\nexport const getIndex = (gameDate: Date) => {\n  let start = firstGameDate\n  let index = -1\n  do {\n    index++\n    start = addDays(start, periodInDays)\n  } while (start <= gameDate)\n\n  return index\n}\n\nexport const getWordOfDay = (index: number) => {\n  if (index < 0) {\n    throw new Error('Invalid index')\n  }\n\n  return localeAwareUpperCase(WORDS[index % WORDS.length])\n}\n\nexport const getSolution = (gameDate: Date) => {\n  const nextGameDate = getNextGameDate(gameDate)\n  const index = getIndex(gameDate)\n  const wordOfTheDay = getWordOfDay(index)\n  return {\n    solution: wordOfTheDay,\n    solutionGameDate: gameDate,\n    solutionIndex: index,\n    tomorrow: nextGameDate.valueOf(),\n  }\n}\n\nexport const getGameDate = () => {\n  if (getIsLatestGame()) {\n    return getToday()\n  }\n\n  const parsed = queryString.parse(window.location.search)\n  try {\n    const d = startOfDay(parseISO(parsed.d!.toString()))\n    if (d >= getToday() || d < firstGameDate) {\n      setGameDate(getToday())\n    }\n    return d\n  } catch (e) {\n    console.log(e)\n    return getToday()\n  }\n}\n\nexport const setGameDate = (d: Date) => {\n  try {\n    if (d < getToday()) {\n      window.location.href = '/?d=' + formatISO(d, { representation: 'date' })\n      return\n    }\n  } catch (e) {\n    console.log(e)\n  }\n  window.location.href = '/'\n}\n\nexport const getIsLatestGame = () => {\n  if (!ENABLE_ARCHIVED_GAMES) {\n    return true\n  }\n  const parsed = queryString.parse(window.location.search)\n  return parsed === null || !('d' in parsed)\n}\n\nexport const { solution, solutionGameDate, solutionIndex, tomorrow } =\n  getSolution(getGameDate())\n"]},"metadata":{},"sourceType":"module"}